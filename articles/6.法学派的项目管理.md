# 法学派的项目管理

用百家争鸣来形容前端近况一点都不为过，各式各样的技术组合成学不完的技术栈（债）。
我欣喜于处在这样一个生命力旺盛的社区，但也为项目的迭代维护感到忧虑。

## 原始部落

新的项目会根据当前人员情况，以快速完成项目为目的，采用项目开发者最擅长或最先进的技术，快速完成项目。

很多项目最开始往往都是这样子的，虽然刚开发完成时看着非常美。但是代价往往是项目之间技术的脱节。
质量也参差不齐。其他开发者需要修改以往项目代码时，需要根据项目代码透露的信息，猜测当时的设计理念。
这在维护时是相当危险的。

## 独裁

相信很多人都听说过[`monorepo`](https://zhuanlan.zhihu.com/p/31289463)。将所有的项目放在一个仓库下进行管理。
这里最出名的实践者就是[Google](https://zhuanlan.zhihu.com/p/70631379)，
`javascript`也有一个工具名为[`lerna`](https://www.npmjs.com/package/lerna)的工具来管理`monorepo`。
这种方式解决了两个`multirepo`的痛点：

1. 模块升级后，所有依赖他的模块都可以根据依赖关系，自动的升级和发版
2. 很容易为所有项目设置统一规范。

但是，也引来了新的问题：

1. 随着项目的增多和项目历史的积累，整个仓库的体积会快速膨胀。
   可是`git`并不适合管理这样的仓库。你可能需要更加强大的版本管理系统`Piper`。
2. [lerna](https://www.npmjs.com/package/lerna)作为管理工具并不容易驾驭。
   你刚开始使用它的时候，各种各样的报错将折磨你的心灵。
   或许是因为目前它还不足够完善，但是目前它的状态就是这样子。
3. 需要每一个项目时刻保持完善的结构和测试。
   以保证其他人修改依赖的项目后，自动化测试能够告知他另外一个项目受到了严重影响。
   因为修改者很可能并不了解其他的项目及其工作原理。
4. 如果不借助其他的版本管理系统，`git`并不容易做权限管理。

综上，个人认为使用`lerna`作为前端项目`monorepo`管理工具，配合`git`作版本管理，更适合管理**大量**的**相互依赖**的**小**模块/库。

## 法制

`monorepo`解决了两个问题，如果只解决其中一个我们是不是能在解决问题的同时，避免更多问题？
如果我们专注于为所有项目设置统一的规范，会发现另一种可行的方案。
这便是[mili](https://www.npmjs.com/package/mili)设计的由来。

我们先设置一个模版，里面规范了项目的目录结构和各种规范。
这个模版就和**法律**一样，所有使用模版的项目必须要遵照其规定。
当对模版进行了升级，使用模版的项目都可以进行升级（就像是一个依赖一样）。
至于会升级成什么样子，都是由模版规定的。

所以模版看上去就像是有人制定了一部*法律*一样，所有项目都必须遵照法律开发。这样做也解决了两个问题：

1. 为所有项目设置统一的规范，避免各个项目使用不同的代码规范。
2. 当项目需要接入统一的服务时，可以通过升级模版来降低工作量。

通过模版的方式，我们便可以将项目分在多个仓库中，
同时避免项目结构和规范的恶性分化问题（也能通过严格的review解决，但是严格的review对于一些团队来说不容易做到）。
因为可以分仓库，所以体积过大和`git`权限控制等问题都没有了。

[mili](https://www.npmjs.com/package/mili) 更适合做多个**web应用项目**或**无相互依赖关系的模块/库**的管理。
它能够使团队的结构、规范和基础服务模块集中在模版中，所有使用模版的项目都能享受升级模版带来的效率提升。
但是它无法解决根据依赖关系自动发版的问题；并且对模版的维护者能力要求更高。不过，总比对所有人要求都高要容易。

由于模版的升级是掌握在项目维护者手里，升级模版可以帮助其自动完成接入新服务、修复公共模块bug或是优化项目开发环境。
维护者可以节约很多时间喝杯咖啡。而对于公共服务的推广和技术的迭代更加容易。因为所有使用模版的项目，项目结构都是一致的。

## 写在最后

项目管理并没有一个完美的解，但是针对每种情况，总能寻找得到一个最优解。
例如`lerna`与`mili`也可以配合使用：用`lerna`解决依赖问题，同时用`mili`解决每个项目的规范问题。
